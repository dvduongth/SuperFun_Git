"use strict";
(function() {

	var instanceId = 0;
	function getInstanceId() {
		return instanceId++;
	}
	// note that this function invoked from call/apply, which has "this" binded	
	function _upload(file, options) {
		var fileReader;
		options = options || {};

		var self = this;
		var socket = this.socket;
		var chunkSize = Math.min(this.chunkSize, file.size);
		var transmissionDelay = this.transmissionDelay;
		var uploadId = file.uploadId;
		var uploadTo = options.uploadTo || '';

		var loadEnded = function () {
			var fileInfo = {
				id: uploadId,
				name: file.name,
				size: file.size,
				chunkSize: chunkSize,
				sent: 0
			};

			uploadTo && (fileInfo.uploadTo = uploadTo);

			// read file
			var buffer = fileReader.result;
			var bufferLength = buffer.byteLength !== undefined ? buffer.byteLength : buffer.length;
			//console.log('buffer', buffer.byteLength);
			console.log('buffer', bufferLength);

			// check file mime type if exists
			if(self.accepts && self.accepts.length > 0) {
				var found = false;

				for(var i = 0; i < self.accepts.length; i++) {
					var accept = self.accepts[i];

					if(file.type === accept) {
						found = true;
						break;
					}
				}

				if(!found) {
					return self.emit('error', new Error('Not Acceptable file type ' + file.type + ' of ' + file.name + '. Type must be one of these: ' + self.accepts.join(', ')));
				}
			}

			// check file size
			if(self.maxFileSize && self.maxFileSize > 0) {
				if(file.size > +self.maxFileSize) {
					return self.emit('error', new Error('Max Uploading File size must be under ' + self.maxFileSize + ' byte(s).'));
				}
			}

			// put into uploadingFiles list
			self.uploadingFiles[uploadId] = fileInfo;

			// request the server to make a file
			console.log('request start');
			self.emit('start', {
				name: fileInfo.name,
				size: fileInfo.size,
				uploadTo: uploadTo
			});
			console.log('request createFile');
			socket.emit('socket.io-file::createFile', fileInfo);

			function sendChunk() {
				// console.log('call sendChunk');

				// socket.emit('socket.io-file::stream::' + uploadId, [1,2,3,4]);//test


				if(fileInfo.aborted) {
					console.log('file aborted', fileInfo.aborted);
					return;
				}

				//if(fileInfo.sent >= buffer.byteLength) {
				if(fileInfo.sent >= bufferLength) {
					//console.log(' send done', fileInfo.sent, buffer.byteLength);
					console.log(' send done', fileInfo.sent, bufferLength);
					socket.emit('socket.io-file::done::' + uploadId);
					return;
				}

				var chunk = buffer.slice(fileInfo.sent, fileInfo.sent + chunkSize);
				socket.emit('socket.io-file::stream::' + uploadId, chunk);

				self.emit('stream', {
					name: fileInfo.name,
					size: fileInfo.size,
					sent: fileInfo.sent,
					uploadTo: uploadTo
				});
				//update info
				//fileInfo.sent += chunk.byteLength;
				var chunkLength = chunk.byteLength !== undefined ? chunk.byteLength : chunk.length;
				fileInfo.sent += chunkLength;
				self.uploadingFiles[uploadId] = fileInfo;

				//todo recursive on request perform function sendChunk
				socket.once('socket.io-file::request::' + uploadId, sendChunk);
			}
			// console.log('listener on request sendChunk', uploadId);
			socket.once('socket.io-file::request::' + uploadId, sendChunk);
			socket.on('socket.io-file::complete::' + uploadId, function(info) {
				self.emit('complete', info);

				socket.removeAllListeners('socket.io-file::abort::' + uploadId);
				socket.removeAllListeners('socket.io-file::error::' + uploadId);
				socket.removeAllListeners('socket.io-file::complete::' + uploadId);

				// remove from uploadingFiles list
				delete self.uploadingFiles[uploadId];
			});
			socket.on('socket.io-file::abort::' + uploadId, function(info) {
				if(typeof info === 'string'){
					info = JSON.parse(info);
				}
				console.log('on file abort');
				fileInfo.aborted = true;
				self.emit('abort', {
					name: fileInfo.name,
					size: fileInfo.size,
					sent: fileInfo.sent,
					wrote: info.wrote,
					uploadTo: uploadTo
				});
			});
			socket.on('socket.io-file::error::' + uploadId, function(err) {
				console.log('on file error');
				self.emit('error', new Error(err.message));
			});
		};
		//todo read file info belong on the platform
		if (file.data) {
			fileReader = {
				result: [].slice.call(file.data)
			};
			loadEnded();
		}else{
			fileReader = new FileReader();
			fileReader.readAsArrayBuffer(file);
			fileReader.addEventListener("loadend", loadEnded);
		}
	}

	function SocketIOFileClient(socket, options) {
		if(!socket) {
			return this.emit('error', new Error('SocketIOFile requires Socket.'));
		}

		this.instanceId = getInstanceId();		// using for identifying multiple file upload from SocketIOFileClient objects
		this.uploadId = 0;						// using for identifying each uploading
		this.ev = {};							// event handlers
		this.options = options || {};
		this.accepts = [];
		this.maxFileSize = undefined;
		this.socket = socket;
		this.uploadingFiles = {};

		var self = this;

		socket.once('socket.io-file::recvSync', function(settings) {
			if(typeof settings === 'string'){
				console.log('socket.io-file::recvSync settings is string', settings);
				settings = JSON.parse(settings);
			}
			self.maxFileSize = settings.maxFileSize || undefined;
			self.accepts = settings.accepts || [];
			self.chunkSize = settings.chunkSize || 10240;
			self.transmissionDelay = settings.transmissionDelay || 0;

			self.emit('ready');
		});
		socket.emit('socket.io-file::reqSync');
	}
	SocketIOFileClient.prototype.getUploadId = function() {
		return 'u_' + this.uploadId++;
	}
	SocketIOFileClient.prototype.upload = function(fileEl, options) {
		if(!fileEl ||
			(fileEl.files && fileEl.files.length <= 0) ||
			fileEl.length <= 0
		) {
			this.emit('error', new Error('No file(s) to upload.'));
			return [];
		}

		var self = this;
		var uploadIds = [];

		var files = fileEl.files ? fileEl.files : fileEl;
		var loaded = 0;

		for(var i = 0; i < files.length; i++) {
			var file = files[i];
			var uploadId = this.getUploadId();
			uploadIds.push(uploadId);

			file.uploadId = uploadId;

			_upload.call(self, file, options);
		}
		
		return uploadIds;
	};
	SocketIOFileClient.prototype.on = function(evName, fn) {
		if(!this.ev[evName]) {
			this.ev[evName] = [];
		}

		this.ev[evName].push(fn);
		return this;
	};
	SocketIOFileClient.prototype.off = function(evName, fn) {
		if(typeof evName === 'undefined') {
			this.ev = [];
		}
		else if(typeof fn === 'undefined') {
			if(this.ev[evName]) {
				delete this.ev[evName]; 
			}
		}
		else {
			var evList = this.ev[evName] || [];

			for(var i = 0; i < evList.length; i++) {
				if(evList[i] === fn) {
					evList = evList.splice(i, 1);
					break;
				}
			}
		}

		return this;
	};
	SocketIOFileClient.prototype.emit = function(evName, args) {
		var evList = this.ev[evName] || [];

		for(var i = 0; i < evList.length; i++) {
			evList[i](args);
		}

		return this;
	};
	SocketIOFileClient.prototype.abort = function(id) {
		var socket = this.socket;
		socket.emit('socket.io-file::abort::' + id);
	};
	SocketIOFileClient.prototype.destroy = function() {
		var uploadingFiles = this.uploadingFiles;

		for(var key in uploadingFiles) {
			this.abort(key);
		}

		this.socket = null;
		this.uploadingFiles = null;
		this.ev = null;
	};
	SocketIOFileClient.prototype.getUploadInfo = function() {
		return JSON.parse(JSON.stringify(this.uploadingFiles));
	};
	SocketIOFileClient.prototype.prettyBytesNumber = function (pBytes, pUnits) {
		// Handle some special cases
		var abbreviations;
		var orderOfMagnitude;
		if(pBytes == 0) return '0 Bytes';
		if(pBytes == 1) return '1 Byte';
		if(pBytes == -1) return '-1 Byte';

		var bytes = Math.abs(pBytes);
		if(pUnits && pUnits.toLowerCase() && pUnits.toLowerCase() == 'si') {
			// SI units use the Metric representation based on 10^3 as an order of magnitude
			orderOfMagnitude = Math.pow(10, 3);
			abbreviations = ['Bytes', 'kB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];
		} else {
			// IEC units use 2^10 as an order of magnitude
			orderOfMagnitude = Math.pow(2, 10);
			abbreviations = ['Bytes', 'KiB', 'MiB', 'GiB', 'TiB', 'PiB', 'EiB', 'ZiB', 'YiB'];
		}
		var i = Math.floor(Math.log(bytes) / Math.log(orderOfMagnitude));
		var result = (bytes / Math.pow(orderOfMagnitude, i));

		// This will get the sign right
		if(pBytes < 0) {
			result *= -1;
		}

		// This bit here is purely for show. it drops the percision on numbers greater than 100 before the units.
		// it also always shows the full number of bytes if bytes is the unit.
		if(result >= 99.995 || i==0) {
			return result.toFixed(0) + ' ' + abbreviations[i];
		} else {
			return result.toFixed(2) + ' ' + abbreviations[i];
		}
	};

	// module export
	// CommonJS
	if (typeof exports === "object" && typeof module !== "undefined") {
		module.exports = SocketIOFileClient;
	}
	// RequireJS
	else if (typeof define === "function" && define.amd) {
		define(['SocketIOFileClient'], SocketIOFileClient);
	}
	else {
		var g;

		if (typeof window !== "undefined") {
			g = window;
		}
		else if (typeof global !== "undefined") {
			g = global;
		}
		else if (typeof self !== "undefined") {
			g = self;
		}

		g.SocketIOFileClient = SocketIOFileClient;
	}
})();