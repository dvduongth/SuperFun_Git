"use strict";
const EventEmitter = require('events').EventEmitter;
const util = require('util');
const fs = require('fs');
const path = require('path');
const mime = require('mime');

function mkdirSyncRecursively(dir, mode) {
    try {
        var result = fs.mkdirSync(dir, mode);
    }
    catch(e) {
        if(e.code === 'ENOENT') {
            mkdirSyncRecursively(path.dirname(dir), mode);  // if does not exists, create all parents recursively
            mkdirSyncRecursively(dir, mode);   // retry
        }
    }
}

function createDirectoryIfNotExists(dir) {
	try {
		fs.accessSync(dir, fs.F_OK);
	}
	catch(e) {
		// create directory if not exists
		mkdirSyncRecursively(dir, '0755');
	}
}

function SocketIOFile(socket, options) {
	if(!socket) {
		console.log('init SocketIOFile with null socket');
		throw new Error('SocketIOFile requires Socket.');
	}

	console.log('init SocketIOFile with options', options);

	this.options = options || {};
	this.maxFileSize = +options.maxFileSize || undefined;
	this.accepts = options.accepts || [];
	this.chunkSize = +options.chunkSize || 10240;
	this.transmissionDelay = options.transmissionDelay || 0;
	this.overwrite = !!options.overwrite || true;
	this.rename = options.rename || null;

	console.log('init SocketIOFile with options.uploadDir', options.uploadDir);
	if(!options.uploadDir) {
		throw new Error('No upload directory specified.');
	}
	
	// check directory is exists
	if(typeof options.uploadDir === 'string') {
		console.log('options.uploadDir is string', options.uploadDir);
		createDirectoryIfNotExists(options.uploadDir);
	}
	else if(typeof options.uploadDir === 'object') {
		for(var key in options.uploadDir) {
			createDirectoryIfNotExists(options.uploadDir[key]);
		}
	}
	else {
		throw new Error('options.uploadDir must be string or object array.');
	}

	this.socket = socket;

	socket.once('socket.io-file::reqSync', () => {
		socket.emit('socket.io-file::recvSync', {
			maxFileSize: this.maxFileSize,
			accepts: this.accepts,
			chunkSize: this.chunkSize,
			transmissionDelay: this.transmissionDelay
		});

		this.emit('ready');
	});
	
	var self = this;
	var uploadingFiles = {};

	socket.on('socket.io-file::createFile', (fileInfo) => {
		if(typeof fileInfo === "string"){
			fileInfo = JSON.parse(fileInfo);
			console.log("json parse fileInfo", fileInfo);
		}
		var info = JSON.parse(JSON.stringify(fileInfo));
        info.size = self.prettyBytesNumber(info.size);
        info.chunkSize = self.prettyBytesNumber(info.chunkSize);
        console.log("on socket.io-file::createFile fileInfo", info);

		var id = fileInfo.id;
		var uploadDir = null;
		var uploadTo = fileInfo.uploadTo || '';

		function sendError(err) {
			socket.emit(`socket.io-file::error::${id}`, {
				message: err.message
			});
			self.emit('error', err);
		}

		var filename = fileInfo.name;
		console.log("filename", filename, id, uploadTo);
		if(this.rename) {
			console.log("rename", this.rename);
			if(typeof this.rename === 'function') {
				filename = this.rename(filename);
			}
			else {
				filename = this.rename;
			}
		}
		
		if(typeof options.uploadDir === 'string') {
			console.log("join path",options.uploadDir,filename);
			uploadDir = path.join(options.uploadDir, filename);
			console.log('uploadDir',uploadDir);
		}
		else if(typeof options.uploadDir === 'object') {
			if(!uploadTo) {
				return sendError(new Error('Upload directory must be specified in multiple directories.'));
			}
			else if(options.uploadDir[uploadTo]) {
                uploadDir = path.join(options.uploadDir[uploadTo], filename);
            }
            else {
				return sendError(new Error('Upload directory ' + uploadTo + ' is not exists.'));
            }
		}
		else if(fileInfo.size > this.maxFileSize) {
			this.emit('error', err);
			return sendError(new new Error('Max Uploading File size must be under ' + this.maxFileSize + ' byte(s).'));
		}

		var startTime = new Date();

		this.emit('start', { 
			name: filename, 
			size: fileInfo.size,
			uploadDir: uploadDir
		});

		var dataArr = [];
		const uploadComplete = () => {
			const ws = uploadingFiles[id].writeStream;

			if(ws) {
				ws.end();
			}

			const endTime = new Date();
			
			const mimeType = mime.lookup(uploadDir);
			const emitObj = {
				name: filename, 
				size: uploadingFiles[id].size, 
				wrote: uploadingFiles[id].wrote,
				uploadDir: uploadingFiles[id].uploadDir,
				mime: mimeType,
				estimated: endTime - startTime
			};
			
			if(this.accepts && this.accepts.length > 0) {
				let found = false;

				for(var i = 0; i < this.accepts.length; i++) {
					let accept = this.accepts[i];

					if(mimeType === accept) {
						found = true;
						break;
					}
				}

				// if mime is invalid, remove files and emit error
				if(!found) {
					fs.unlink(uploadDir);	// no after works.

					let err = new Error('Not Acceptable file type ' + mimeType + ' of ' + filename + '. Type must be one of these: ' + this.accepts.join(', '));
					this.emit('error', err);
					return sendError(err);
				}
				else {
					self.emit('complete', emitObj);

					delete emitObj.uploadDir;
					self.socket.emit(`socket.io-file::complete::${id}`, emitObj);
				}
			}
			else {
				self.emit('complete', emitObj);

				delete emitObj.uploadDir;
				self.socket.emit(`socket.io-file::complete::${id}`, emitObj);
			}			

			// Release event handlers
			socket.removeAllListeners(`socket.io-file::stream::${id}`);
			socket.removeAllListeners(`socket.io-file::done::${id}`);
			socket.removeAllListeners(`socket.io-file::complete::${id}`);
			socket.removeAllListeners(`socket.io-file::abort::${id}`);
			socket.removeAllListeners(`socket.io-file::error::${id}`);

			delete uploadingFiles[id];
		};

		uploadingFiles[id] = {
			writeStream: null,
			name: fileInfo.name,
			size: fileInfo.size,
			wrote: 0,
			uploadDir: uploadDir
		};

		console.log("check overwrite", options.overwrite, this.overwrite);
		if(!this.overwrite) {
			let isFileExists = false;

			try {
				fs.accessSync(uploadDir, fs.F_OK);
				isFileExists = true;
			}
			catch(e) {
				console.log('File is not exists, so create new one.');
			}

			if(isFileExists) return uploadComplete();
		}

		var writeStream = fs.createWriteStream(uploadDir);
		
		uploadingFiles[id].writeStream = writeStream;

		socket.emit(`socket.io-file::request::${id}`);

		socket.on(`socket.io-file::stream::${id}`, (chunk) => {
			// console.log("stream chunk", typeof chunk, chunk);
			var isParseChunk = false;
			if(typeof chunk === 'string'){
				// var startT = new Date();
				//chunk = new Buffer(JSON.parse(chunk));
				chunk = JSON.parse(chunk);
				isParseChunk = true;
				// var endT = new Date();
				// console.log('stream parse json chunk ' + (endT - startT));
			}

			if(uploadingFiles[id].abort) {
				socket.removeAllListeners(`socket.io-file::stream::${id}`);
				socket.removeAllListeners(`socket.io-file::done::${id}`);
				socket.removeAllListeners(`socket.io-file::complete::${id}`);
				socket.removeAllListeners(`socket.io-file::abort::${id}`);
				socket.removeAllListeners(`socket.io-file::error::${id}`);

				uploadingFiles[id].writeStream.end();
				delete uploadingFiles[id];
				return;
			}

			var writeStream = uploadingFiles[id].writeStream;

			function write() {
				let result = (uploadingFiles[id].wrote + chunk.length) > (self.maxFileSize);
				
				if( (uploadingFiles[id].wrote + chunk.length) > (self.maxFileSize)) {
					return sendError(new Error(`Uploading file size exceeded max file size ${self.maxFileSize} byte(s).`));
				}

				// var startTWrite = new Date();
				//var writeDone = writeStream.write(chunk);
				var writeDone;
				if(isParseChunk){
					writeDone = writeStream.write(new Buffer(chunk));
				}else{
					writeDone = writeStream.write(chunk);
				}
				// var endTWrite = new Date();
				// console.log('write chunk ' + (endTWrite - startTWrite));

				uploadingFiles[id].wrote += chunk.length;

				self.emit('stream', {
					name: uploadingFiles[id].name, 
					size: uploadingFiles[id].size, 
					wrote: uploadingFiles[id].wrote,
					uploadDir: uploadingFiles[id].uploadDir
				});

				if(!writeDone) {
					writeStream.once('drain', () => socket.emit(`socket.io-file::request::${id}`));
				}
				else {
					// console.log("self.transmissionDelay", self.transmissionDelay);
					if(self.transmissionDelay) {
						setTimeout(() => {
							socket.emit(`socket.io-file::request::${id}`);
						}, self.transmissionDelay);
					}
					else {
						socket.emit(`socket.io-file::request::${id}`);
					}
				}
			}

			write();
		});
		socket.on(`socket.io-file::done::${id}`, () => {
			uploadComplete();
		});
		socket.on(`socket.io-file::abort::${id}`, () => {
			uploadingFiles[id].abort = true;

			self.emit('abort', {
				name: uploadingFiles[id].name, 
				size: uploadingFiles[id].size, 
				wrote: uploadingFiles[id].wrote,
				uploadDir: uploadingFiles[id].uploadDir
			});
			socket.emit(`socket.io-file::abort::${id}`, {
				name: uploadingFiles[id].name, 
				size: uploadingFiles[id].size, 
				wrote: uploadingFiles[id].wrote,
				uploadDir: uploadingFiles[id].uploadDir
			});
		});
	});
}
util.inherits(SocketIOFile, EventEmitter);
SocketIOFile.prototype.prettyBytesNumber = function (pBytes, pUnits) {
        // Handle some special cases
        var abbreviations;
        var orderOfMagnitude;
        if(pBytes == 0) return '0 Bytes';
        if(pBytes == 1) return '1 Byte';
        if(pBytes == -1) return '-1 Byte';

        var bytes = Math.abs(pBytes);
        if(pUnits && pUnits.toLowerCase() && pUnits.toLowerCase() == 'si') {
            // SI units use the Metric representation based on 10^3 as an order of magnitude
            orderOfMagnitude = Math.pow(10, 3);
            abbreviations = ['Bytes', 'kB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];
        } else {
            // IEC units use 2^10 as an order of magnitude
            orderOfMagnitude = Math.pow(2, 10);
            abbreviations = ['Bytes', 'KiB', 'MiB', 'GiB', 'TiB', 'PiB', 'EiB', 'ZiB', 'YiB'];
        }
        var i = Math.floor(Math.log(bytes) / Math.log(orderOfMagnitude));
        var result = (bytes / Math.pow(orderOfMagnitude, i));

        // This will get the sign right
        if(pBytes < 0) {
            result *= -1;
        }

        // This bit here is purely for show. it drops the percision on numbers greater than 100 before the units.
        // it also always shows the full number of bytes if bytes is the unit.
        if(result >= 99.995 || i==0) {
            return result.toFixed(0) + ' ' + abbreviations[i];
        } else {
            return result.toFixed(2) + ' ' + abbreviations[i];
        }
    };
module.exports = SocketIOFile;